---
layout: post
title: "windows下自启动权限问题记录"
date:   2024-7-08
tags: [windows系统, 自启动, 权限]
comments: true
author: daichuan
---

本篇文档讲述在windows环境下，配置HKLM实现程序自启动时遇到的文件读取权限问题及解决方法。

<!-- more -->

#### 简单的自启动配置有两种方法：

方法一：添加注册表（需管理员权限）

```
//用户级
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce
//管理员权限
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
```

方法二：向启动目录添加快捷方式

```
//自启动目录
C:\Users\Username\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup //目录对特定用户生效， 
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp //对所有用户生效。
```

#### 遇到的问题：

**程序位于`"C:\\test"`下，点击运行、采用方法二运行均正常；采用方法一运行，程序会闪退。**

程序首段如下，采用相对路径创建并写入日志文件，创建的日志文件权限：`0644`。

```go
logFile := "logfile.log"
file, err := os.OpenFile(logFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		log.Println(err)
		time.Sleep(10 * time.Second)
		return
	}
	defer file.Close()
```

问题在于：==HKLM下注册表自启动的程序的工作目录与另外两方式启动的不同。==

1、创建一个test测试程序，并配置自启动，验证自启动的程序的工作目录：

```go
func main() {
	currentDir, err := os.Getwd() // 获取当前工作目录
	if err != nil {
		fmt.Println("获取当前工作目录时出错:", err)
		return
	}
	fmt.Println("当前工作目录:", currentDir)
	time.Sleep(50 * time.Second)
} 
```

配置自启动后运行：

方法一的结果：`当前工作目录: C:\Windows\system32`，因此找不到源文件夹下的配置文件，也没有权限创建新的文件。

方法二的结果：`当前工作目录：C:\test\client`

==另一个问题，两种方式运行的程序的身份权限是否会导致该问题？（不会）==

```
[GPT4o]：
注册表自启动：程序可能以系统权限或服务权限运行，具体取决于添加注册表项的位置和设置。例如，如果在 HKEY_LOCAL_MACHINE 下添加自启动项，程序会以系统权限运行。如果在 HKEY_CURRENT_USER 下添加自启动项，程序会以当前用户的权限运行。
系统权限运行的程序通常可以访问和写入用户创建的文件，但可能会受到某些访问控制列表 (ACL) 和权限设置的限制。权限设置为 0644 的文件意味着所有者可以读写，其他用户只能读取。因此，如果程序以系统权限运行，通常能够写入这些文件，前提是系统账户有足够的权限。
```

2、创建一个test2测试程序，并配置自启动，验证自启动身份不同导致的0644权限问题：

```go
func main() {
	logFile := "C:\\test\\logfile.log"
	file, err := os.OpenFile(logFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		log.Println(err)
		time.Sleep(10 * time.Second)
		return
	}
	defer file.Close()
	fmt.Println("logfile Opened")
	time.Sleep(50 * time.Second)
}
```

首先，通过用户直接点击的方式运行程序，然后配置自启动后重启。

方法一的结果：`logfile Opened`

方法二的结果：`logfile Opened`
